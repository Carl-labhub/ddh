---
title: "Methods"
author: Matthew Hirschey
output: md_document
---

```{r setup, include=FALSE}
###knit this documet to generate methods.md, which then is served by the Shiny app###
knitr::opts_chunk$set(echo = TRUE)
library(lubridate)
library(tidyverse)
library(feather)
library(knitr)
library(cowplot)
library(viridis)
library(corrr)
library(here)
library(patchwork)
library(enrichR)
library(tidygraph)
library(ggraph)
library(pander)

#read current release information 
source(here::here("code", "current_release.R"))

##LOAD DATA
fav_gene <- "TP53"
load(file = here::here("data", "gene_summary.RData"))
load(file = here::here("data", paste0(release, "_achilles.Rdata")))
load(file = here::here("data", paste0(release, "_achilles_cor.Rdata")))
class(achilles_cor) <- c("cor_df", "tbl_df", "tbl", "data.frame")
load(file = here::here("data", paste0(release, "_expression.Rdata")))
load(file = here::here("data", paste0(release, "_expression_join.RData")))

#LOAD STATS
sd_threshold <- readRDS(file = here::here("data", "sd_threshold.rds"))
achilles_lower <- readRDS(file = here::here("data", "achilles_lower.rds"))
achilles_upper <- readRDS(file = here::here("data", "achilles_upper.rds"))
mean_virtual_achilles <- readRDS(file = here::here("data", "mean_virtual_achilles.rds"))
sd_virtual_achilles <- readRDS(file = here::here("data", "sd_virtual_achilles.rds"))

#clear environment
#rm(list=ls()) 

#pathway enrichment analysis loop function
enrichr_loop <- function(gene_list, databases){
  if(is_empty(gene_list)){
    flat_complete <- NULL
    return(flat_complete)
  } else {
    flat_complete <- as_tibble()
    for(lib in databases){
      enriched <- enrichr(gene_list, lib)
      
      flat <- flatten_dfc(enriched) %>% 
        mutate(enrichr = lib)
      
      flat_complete <- flat_complete %>% 
        bind_rows(flat)
    }
    flat_complete <- flat_complete %>% 
      arrange(Adjusted.P.value) %>% 
      select(enrichr, Term, Overlap) 
    
    flat_complete$enrichr <- str_replace_all(flat_complete$enrichr, "\\_", " ")
    flat_complete$Term <- str_replace_all(flat_complete$Term, "\\_", " ")
    return(flat_complete)
  }
}
```

![searching under the lamppost](`r "https://source.unsplash.com/y41FEMqdJ3A/400x300"`)  
  
## Why this project?
Like the proverbial man [searching for his lost keys under the lamp post](https://www.matthewhirschey.com/articles/exploratory-mind) because the light shines there, searching for biological truths often occurs under 'lamp posts' because that's where scientists can see. But what if your keys are not under the light? Or your gene is totally unknown? What do you do?  
  
The scientific method has guided scientific minds for hundreds of years, starting with a question, followed by a hypothesis, and then an experimental path to test the prediction. While hypotheses are the bedrock of science, the volume, complexity, and sophistication of modern science necessitate new methods to generate hypotheses.  
  
New tools in Data Science -- a combination of computer programming, math & statistics, and topical expertise -- combined with the rapid adoption of open science and data sharing allow scientists to access publicly available datasets and interrogate these data *before* performing any experiments.  
  
Imagine having strong data to support your new hypothesis *before* testing it. Welcome to data-driven hypothesis.

## What is this project?
The overall goal of the data-driven hypothesis (DDH) project is to use new tools in Data Science to generate hypotheses supported by data that can be tested in the lab.  
  
Several high-quality, functional genomic datasets are published online and made available with Creative Commons Attribution 4.0 International [(CC BY 4.0)](https://creativecommons.org/licenses/by/4.0/) licenses. Functional genomics is a field of molecular biology that aims to understand the function of all genes and proteins in a genome -- a stated goal of much basic science research. In functional genomics, experimental strategies generally involve high-throughput, genome-wide approaches rather than a more traditional “gene-by-gene” approach. The advent and rapid adoption of data-sharing platforms, such as [figshare.com](https://figshare.com) have provided high-quality data sets for public interrogation. The DDH project aims to integrate functional genomics data and holds tremendous promise to generate hypotheses, data, and knowledge in order to provide a deep understanding of the dynamic properties of an organism.  
    
## How does it work?
This project began as an extension of a simple and common concept in molecular biology called gene co-expression analysis. When a gene of unknown function is identified, one strategy to learn something about the new gene is to identify shared patterns of expression with other genes. If unknown Gene X is expressed with known genes A, B, and C, then you can infer that Gene X might be part of a functional module with A, B, C. This approach is particularly powerful when genes A, B, and C are part of a known biological pathway, which leads to the hypothesis that Gene X might also be part of that same pathway.  
  
```{r gene_coexpression, echo=FALSE}
# Dummy data
x <- paste0("CTL ", seq(1,3))
x <- x %>% 
  c(x <- paste0("EXP ", seq(1,3)))
y <- paste0("gene ", LETTERS[24])
y <- y %>% 
  c(paste0("gene ", LETTERS[1:6]))
data <- expand.grid(X=x, Y=y, stringsAsFactors = TRUE)

pos <- runif(100, 0.2, 1)
neg <- runif(100, -1, -0.2)

i <- 0
A <- NULL
while (i < 4) {
  a <- sample(pos, 3)
  a <- a %>% c(sample(neg,3))
  A <- c(A, a)
  i <- i + 1
}
j <- 0
B <- NULL
while (j < 3) {
  b <- sample(neg, 3)
  b <- b %>% c(sample(pos,3))
  B <- c(B, b)
  j <- j + 1
}

data$Z <- c(A,B)

# Heatmap 
ggplot(data, aes(X, fct_rev(Y), fill= Z)) + 
  geom_tile() +
  labs(x = "", y = "", fill = "Gene \nCorrelation", title = "Gene Coexpression Example*", caption = "*simulated data") +
  theme_minimal_grid(color = "white") +
  scale_x_discrete(position = "top")
```
  
Following on this idea, we set out to map genes to common functional pathways based on dependence of a pathway for cell viability. Project Achilles is a systematic effort by the [Broad Institute](https://www.broadinstitute.org) as part of a larger ['DepMap' project](http://www.depmap.org) aimed at identifying and cataloging gene essentiality across hundreds of well-characterized cancer cell lines using highly standardized pooled genome-scale loss-of-function screens. This project uses lentiviral-based pooled RNAi or CRISPR/Cas9 libraries to systematically knock-out each gene in the genome, which allows for the stable suppression/ablation of each gene individually in a subset of cells within a pooled format allowing for genome wide interrogation of gene essentiality. Using computational modeling, a normalized value of gene essentiality is given for each gene in a single cell line. A lower score means that a gene is more likely to be essential in a given cell line. A score of -1 corresponds to the median of all common essential genes, whereas a score of 0 is equivalent to a gene that is not essential; a positive score indicates a gain in fitness and often identifies tumor suppressor genes.  
  
It is well-known that human cancer cell lines rely on different pathways for their viability. Indeed this is the entire rationale for personalized, precision medicine in cancer. The overall goal of the 'DepMap' project is to identify all essential genes in 2000 cell lines over the 5-year project period to identify new therapeutic targets in various cancers. Despite not knowing the mechanistic basis for why some cell lines require specific genes while other cell lines do not, we reasoned that intrinsic reliance of a cell on a pathway might allow unbiased detection of novel genes participating in specific pathways.  
  
```{r cell_dependency, echo=FALSE}
# Dummy data
x <- paste0("cell line ", seq(1,6))
y <- paste0("gene ", LETTERS[24])
y <- y %>% 
  c(paste0("gene ", LETTERS[1:6]))
data <- expand.grid(X=x, Y=y, stringsAsFactors = TRUE)

pos <- runif(100, 0.2, 1)
neg <- runif(100, -1, -0.2)

i <- 0
A <- NULL
while (i < 3) {
  a <- sample(pos, 3)
  a <- a %>% c(sample(neg,3))
  A <- c(A, a)
  i <- i + 1
}
j <- 0
B <- NULL
while (j < 4) {
  b <- sample(neg, 3)
  b <- b %>% c(sample(pos,3))
  B <- c(B, b)
  j <- j + 1
}

data$Z <- c(B,A)

# Heatmap 
ggplot(data, aes(X, fct_rev(Y), fill= Z)) + 
  geom_tile() +
  labs(x = "", y = "", fill = "Dependency \nScore", title = "Dependency Score Example*", caption = "*simulated data") +
  theme_minimal_grid(color = "white") + 
  scale_fill_viridis() + 
  scale_x_discrete(position = "top")
```
  
## What did I do?
Essential gene data from Project Achilles were downloaded from the DepMap portal at:  [depmap.org](https://depmap.org/portal/download/). The `r release` release contains gene essentiality scores for `r ncol(achilles)` genes across `r nrow(achilles)` cell lines, and was used for this project. 
  
```{r dep_scores, echo=FALSE}
#insert summary of scores
achilles_long <- achilles %>% 
  pivot_longer(-X1, names_to = "gene", values_to = "dep_score") %>% 
  filter(!is.na(dep_score))

#sample_n(achilles_long, 5000)

ggplot() +
  geom_histogram(data = achilles_long, aes(x = dep_score), color = "gray", binwidth = 0.1) +
  labs(x = "Dependency Score", y = "Count (Million)", title = paste0("Dependency Score Distribution from DepMap release ", release)) +
  scale_y_continuous(breaks = c(0, 500000, 1000000, 1500000, 2000000), labels = c("0", "0.5", "1", "1.5", "2")) +
  scale_x_continuous(breaks = c(-5:7)) +
  theme_cowplot()
```
  
#### Patterns
To find patterns in gene dependencies across cell lines, we generated a Pearson correlation matrix of all genes by all genes. This analysis generated gene-gene correlation values that matched values published on [depmap.org](https://depmap.org), validating the first step in our analysis. High levels of gene expression are often thought to be indicative of key genes for a given cell type. Thus, we next compared dependency values to gene expression values. The [Cancer Cell Line Encyclopedia](https://portals.broadinstitute.org/ccle/about) project is a collaboration between the Broad Institute, and the Novartis Institutes for Biomedical Research and its Genomics Institute of the Novartis Research Foundation, which together conduct detailed genetic and pharmacologic characterization of a large panel of human cancer models. As of the CCLE 2019 release, `r nrow(expression)` cell lines have been characterized for gene expression. In the `r release` DepMap release, `r sum(expression$X1 %in% achilles$X1 == TRUE)` of the `r nrow(achilles)` cell lines have gene expression data. Using these two datasets, we compared the essentiality of a gene to its expression value.  
  
```{r depVexp, echo=FALSE, message=FALSE, warning=FALSE}
expression_long <- expression %>% 
  filter(expression$X1 %in% achilles$X1 == TRUE) %>% #matches cells and makes sure I'm analysing CCLE cells in Achilles
  pivot_longer(-X1, names_to = "gene", values_to = "gene_expression") %>% 
  arrange(desc(gene_expression))

joined <- expression_long %>% 
  left_join(achilles_long, by = c("gene" = "gene", "X1" = "X1"))

log_breaks <- c(1, 10, 100, 1000, 10000, 100000, 1000000)
log_break_labels <-c("1", "10", "100", "1,000", "10,000", "100,000", "1,000,000")
joined %>% 
  #sample_n(10000) %>% 
  ggplot() +
  geom_hex(aes(x = dep_score, y = gene_expression), 
           bins = 90, na.rm = TRUE, size = 0.2, color = "black") +
  scale_fill_viridis_c(option = "C", name = "Count", trans = "log10", breaks = log_breaks, labels = log_break_labels) + #log scale transform legend
  labs(x = "Dependency Score", y = "Gene Expression", title = "Gene expression is unrelated to its essentiality") +  
  #coord_fixed() +
  theme_cowplot()
```
  
We predicted a V-shaped curve, with stronger dependencies as gene expression increases. Surprisingly, we saw no relationship between gene expression and gene essentiality, where genes with both low and high expression displayed both gains and losses in fitness. The overall observation from this dataset shows baseline gene expression levels are poor indicators of the essentiality of a gene. This analysis also highlighted that several genes were binned on the x-axis, i.e. could have no measurable expression levels, but have assigned dependency scores. Across `r nrow(achilles)` cell lines in the Achilles project, `r round(((expression_long %>% filter(gene_expression == 0) %>% count())/(length(expression_long$gene_expression))*100), digits = 1)`% of all gene expression values are zero, confirming this notion. 
  
#### Noise Reduction
Given cells do not express all genes, but might receive a dependency sore in this experimental paradigm, we sought to remove dependency scores for gene-cell line pairs that have an expression value of zero under basal conditions. Of the `r nrow(achilles)` cell lines for which gene essentiality data is collected, `r sum(achilles$X1 %in% expression$X1)` have genome-wide gene expression data. From these cell lines, we removed dependency scores for genes from cell line that have a corresponding gene expression value of zero.  
  
```{r expression_0, echo=FALSE, message=FALSE, warning=FALSE}
#how many 0s?
ggplot() +
  geom_histogram(data = expression_long, aes(x = gene_expression), color = "gray", binwidth = 0.25) +
  labs(title = paste("Binned gene expression values in ", sum(achilles$X1 %in% expression$X1), " Achilles cell lines", sep = ""), 
       subtitle = paste0(
    round(((expression_long %>% filter(gene_expression == 0) %>% count())/(length(expression_long$gene_expression))*100), digits = 1), "% of all values are zero"), 
    x = "Gene expression (RPKM)", 
    y = "Count (Million)") +
  scale_y_continuous(breaks = seq(0, 3000000, by = 1000000), labels = c("0", "1", "2", "3")) +
  theme_cowplot() +
  NULL
```
  
For some genes expressed in highly specific and restricted cell types, this operation removed many dependency values. After removing these values, we found that highly specialized genes in discrete cell types  have too few cells with both gene expression values and gene essentiality values to assign a meaningful correlation value. Thus, if a gene was absent from too many cell lines, we omitted it to prevent assigned values from relying on too few data points.  
  
```{r dep_cleaning, echo=FALSE, message=FALSE, warning=FALSE}
no_expression <- expression_long %>% 
  filter(gene_expression == 0) %>% 
  unite(X1, gene, col = "match", sep = "-", remove = TRUE) %>% 
  pull(match)

achilles_no0 <- achilles_long %>% 
  unite(X1, gene, col = "match", sep = "-", remove = FALSE) %>% 
  filter(match %in% no_expression == FALSE) %>% 
  select(-match) %>%
  spread(gene, dep_score)

#count NAs in corrected dataframe
achilles_no0_plot <- achilles_no0 %>% 
  summarise_all(list(~sum(is.na(.)))) %>% 
  gather(gene, NAs) %>% 
  arrange(desc(NAs)) %>% 
  mutate(pos = sum(achilles$X1 %in% expression$X1)-NAs)

#this is code to draw arrows graph labels
arrows <- tibble(
  x1 = c(sum(achilles$X1 %in% expression$X1)-na_cutoff, sum(achilles$X1 %in% expression$X1)-na_cutoff),
  x2 = c(375, 50),
  y1 = c(6000, 8000),
  y2 = c(2500, 5000)
)

ggplot(achilles_no0_plot) +
  geom_histogram(aes(x = pos), color = "gray") +
  labs(x = "Number of Cell Lines", y = "Number of Genes in Bin", title = "The number of cell lines each gene was present within") +
  geom_curve(data = arrows, aes(x = x1, y = y1, xend = x2, yend = y2),
             arrow = arrow(length = unit(0.07, "inch")), size = 0.4,
             color = "gray60", curvature = .20) +
  annotate("text", x = 35, y = 3000, size = 4, color = "gray60",
           label = glue::glue("These genes \nhave too few \ncells with \nexpression")) +
  annotate("text", x = 500, y = 2500, size = 4, color = "gray60",
           label = glue::glue("These genes have several \ncell lines with expression")) +
  annotate("text", x = sum(achilles$X1 %in% expression$X1)-na_cutoff + 5, y = 12000, size = 3, color = "red", hjust = 0, fontface = "bold",
           label = glue::glue("Threshold")) +
  geom_vline(aes(xintercept = sum(achilles$X1 %in% expression$X1)-na_cutoff), color = "red") +
  theme_cowplot()

toomanyNAs <- achilles_no0 %>% 
  summarise_all(list(~sum(is.na(.)))) %>% 
  gather(gene, NAs) %>% 
  arrange(desc(NAs)) %>% 
  filter(NAs > na_cutoff) %>% 
  pull(gene)

achilles_clean <- achilles_no0 %>% 
  select(-one_of(toomanyNAs)) #would be nice to list these, but lose the kable in Rmd->md->html conversion
```
  
We set a threshold of no more than `r na_cutoff` zeros, meaning that if a gene had fewer than `r nrow(achilles)-na_cutoff` cell lines with dependency values, the correlation pattern of a gene would be meaningless, and that gene was therefore removed. This process removed `r length(toomanyNAs)`  genes that had too few cells with expression and dependency data. These 'cleaned' dependency data had `r length(achilles_clean)` remaining gene-dependency pairs, which were then used to generate correlation matrix.  
  
## How does it work?
To identify genes that shared similar patterns of essentiality with other genes, thereby placing genes in functional pathways, we generated a Pearson correlation matrix on these prioritized data in order to quantify the similarity in dependency patterns and annotate genes in functional pathways.  

```{r r2, echo=FALSE}
achilles_cor_long <- achilles_cor %>% 
  stretch()

achilles_cor_long %>% 
  filter(!is.na(r)) %>% 
  #sample_n(1000) %>% 
  ggplot() +
  geom_histogram(aes(x = r), color = "gray", binwidth = 0.05) +
  scale_y_continuous(breaks = c(0, 25000000, 50000000, 75000000), labels = c("0", "25", "50", "75")) +
  labs(x = "r^2 values", y = "Count (Million)", title = "Distribution of r^2 values across all gene-gene pairs") +
  theme_cowplot()
```
  
This process generated approximately `r round(nrow(achilles_cor_long)/1000000, 0)` million correlation values, with a distribution centered around zero. This output produced a range of maximum correlation values for each gene.  
  
```{r achilles_max, echo=FALSE}
achilles_cor %>% 
  select(-rowname) %>% 
  summarize_all(list(~max(., na.rm = TRUE))) %>% 
  gather("gene", "max") %>% 
  arrange(desc(max)) %>% 
  ggplot(aes(max)) +
  geom_histogram(binwidth = 0.05, color = "gray") + 
  #geom_vline(aes(xintercept = achilles_upper), color = "red") +
  labs(title = "Distribution of maximum r^2 values for each gene", x = "Maximum r^2 values", y = "Count") +
  theme_cowplot()

```
  
#### Statistics
Rather than setting an arbitrary threshold for the r^2 value that would be considered a low, medium, or high correlation between two genes, we performed a permutation test on the correlated data. A permutation test involves permuting one or more variables in a data set before performing the test, in order to break any existing relationships and simulate the null hypothesis. In this case, we broke the relationship between gene-gene pairs and the correlation values. We can then compare the true statistic (mean correlation) to the generated distribution of null statistics (fake means), along with standard deviations of these sampled data. This strategy will give a better idea of where to draw a threshold of a "significant correlation" for these analyses. We sampled 20,000 r^2 values from all gene-gene pairs without replacement simulating a virtual Achilles dataset for a single cell. We then repeated this process 1000 times mimicking 1000 discrete cell lines.  
  
This statistical analysis produced the following data:  
**Mean:** `r mean_virtual_achilles`  
**Standard Deviation:** `r sd_virtual_achilles`  
  
Using a standard deviation threshold of `r sd_threshold`, we calculated the boundaries of r^2 values to be greater than `r round(achilles_upper, 2)` or lower than `r round(achilles_lower, 2)` for negative correlations.  
  
#### Pathway Analyses
```{r focused_lib, echo=FALSE}
focused_lib <- c("Achilles_fitness_decrease", "Achilles_fitness_increase", "Aging_Perturbations_from_GEO_down", "Aging_Perturbations_from_GEO_up", "Allen_Brain_Atlas_down", "Allen_Brain_Atlas_up", "ARCHS4_Cell-lines", "ARCHS4_IDG_Coexp", "ARCHS4_Kinases_Coexp", "ARCHS4_TFs_Coexp", "ARCHS4_Tissues", "BioCarta_2016", "BioPlex_2017", "Cancer_Cell_Line_Encyclopedia", "ChEA_2016", "Chromosome_Location_hg19", "CORUM", "Data_Acquisition_Method_Most_Popular_Genes", "Disease_Perturbations_from_GEO_down", "Disease_Perturbations_from_GEO_up", "Disease_Signatures_from_GEO_up_2014", "Drug_Perturbations_from_GEO_down", "Drug_Perturbations_from_GEO_up", "DrugMatrix", "DSigDB", "ENCODE_and_ChEA_Consensus_TFs_from_ChIP-X", "ENCODE_Histone_Modifications_2015", "ENCODE_TF_ChIP-seq_2015", "Enrichr_Libraries_Most_Popular_Genes", "Enrichr_Submissions_TF-Gene_Coocurrence", "Epigenomics_Roadmap_HM_ChIP-seq", "ESCAPE", "GeneSigDB", "GO_Biological_Process_2018", "GO_Cellular_Component_2018", "GO_Molecular_Function_2018", "GTEx_Tissue_Sample_Gene_Expression_Profiles_down", "GTEx_Tissue_Sample_Gene_Expression_Profiles_up", "GWAS_Catalog_2019", "HMDB_Metabolites", "HomoloGene", "Human_Gene_Atlas", "Human_Phenotype_Ontology", "HumanCyc_2015", "HumanCyc_2016", "huMAP", "InterPro_Domains_2019", "Jensen_COMPARTMENTS", "Jensen_DISEASES", "Jensen_TISSUES", "KEA_2015", "KEGG_2019_Human", "KEGG_2019_Mouse", "Kinase_Perturbations_from_GEO_down", "Kinase_Perturbations_from_GEO_up", "Ligand_Perturbations_from_GEO_down", "Ligand_Perturbations_from_GEO_up", "LINCS_L1000_Chem_Pert_down", "LINCS_L1000_Chem_Pert_up", "LINCS_L1000_Kinase_Perturbations_down", "LINCS_L1000_Kinase_Perturbations_up", "LINCS_L1000_Ligand_Perturbations_down", "LINCS_L1000_Ligand_Perturbations_up", "MCF7_Perturbations_from_GEO_down", "MCF7_Perturbations_from_GEO_up", "MGI_Mammalian_Phenotype_Level_4_2019", "Microbe_Perturbations_from_GEO_down", "Microbe_Perturbations_from_GEO_up", "miRTarBase_2017", "Mouse_Gene_Atlas", "MSigDB_Computational", "MSigDB_Oncogenic_Signatures", "NCI-60_Cancer_Cell_Lines", "NURSA_Human_Endogenous_Complexome", "Old_CMAP_down", "Old_CMAP_up", "OMIM_Disease", "OMIM_Expanded", "Panther_2016", "Pfam_Domains_2019", "Pfam_InterPro_Domains", "Phosphatase_Substrates_from_DEPOD", "PPI_Hub_Proteins", "Rare_Diseases_AutoRIF_ARCHS4_Predictions", "Rare_Diseases_AutoRIF_Gene_Lists", "Rare_Diseases_GeneRIF_ARCHS4_Predictions", "Rare_Diseases_GeneRIF_Gene_Lists", "Reactome_2016", "RNA-Seq_Disease_Gene_and_Drug_Signatures_from_GEO", "SILAC_Phosphoproteomics", "Single_Gene_Perturbations_from_GEO_down", "Single_Gene_Perturbations_from_GEO_up", "SubCell_BarCode", "SysMyo_Muscle_Gene_Sets", "TargetScan_microRNA_2017", "TF_Perturbations_Followed_by_Expression", "TF-LOF_Expression_from_GEO", "Tissue_Protein_Expression_from_Human_Proteome_Map", "Tissue_Protein_Expression_from_ProteomicsDB", "Transcription_Factor_PPIs", "TRANSFAC_and_JASPAR_PWMs", "TRRUST_Transcription_Factors_2019", "UK_Biobank_GWAS", "Virus_Perturbations_from_GEO_down", "Virus_Perturbations_from_GEO_up", "VirusMINT", "WikiPathways_2019_Human", "WikiPathways_2019_Mouse")
#find a way to out put this in a simple/clean format?
```
To identify clusters of genes with shared relationships, we performed gene set enrichment analysis. Enrichment analysis is a computational method for inferring knowledge about a target gene set by comparing it to annotated gene sets representing prior biological knowledge. Enrichment analysis determines whether an input set of genes significantly overlaps with annotated gene sets. For each gene in our matrix, we determined the number of genes that were greater than or less than `r sd_threshold` standard deviations away from the permuted mean. This target gene list was then queried against `r length(focused_lib)` gene sets across a [broad range of curated data](https://amp.pharm.mssm.edu/Enrichr/#stats). By leveraging the [Enrichr](https://amp.pharm.mssm.edu/Enrichr/) resource from the [Ma'ayan Laboratory](http://labs.icahn.mssm.edu/maayanlab/), we determined the top ranked pathways, processes, drugs, cell lines, tissues, or diseases, and ranked by p-value. In this setting, the p-value is computed using a standard statistical method used by most enrichment analysis tools: Fisher's exact test or the hypergeometric test. This is a binomial proportion test that assumes a binomial distribution and independence for probability of any gene belonging to any set. [See here for more information about how Enrichr computes its associations](https://amp.pharm.mssm.edu/Enrichr/help#background).  
  
## How do I use this?
In order to identify the functional annotation of a single gene, begin with a query. Entering a single gene in the search box produces a series of tables and plots that identifies a functional map of the processes that gene *might* be involved in. In some cases, a querying gene with known functions will identify gene with well-established connections to the query gene; in other cases, new genes and new biological process might be identified, suggesting there is more to discover for well-known pathways. Querying unknown genes is especially powerful, as the associated genes and pathways provide a starting point for an otherwise difficult problem to prioritize experimentally.  
  
```{r p53_code, message=FALSE, warning=FALSE, include=FALSE}
#summary
    fav_gene_summary <- gene_summary %>% 
      filter(approved_symbol == fav_gene)
    
    #dep tables
    dep_top <- achilles_cor %>% 
      focus(fav_gene) %>% 
      arrange(desc(.[[2]])) %>% #use column index
      filter(.[[2]] > achilles_upper) %>% #formerly top_n(20), but changed to mean +/- 3sd
      rename(approved_symbol = rowname) %>% 
      left_join(gene_summary, by = "approved_symbol") %>% 
      select(approved_symbol, approved_name, fav_gene) %>% 
      rename(gene = approved_symbol, name = approved_name, r2 = fav_gene)
    
    dep_bottom <- achilles_cor %>% 
      focus(fav_gene) %>% 
      arrange(.[[2]]) %>% #use column index
      filter(.[[2]] < achilles_lower) %>% #formerly top_n(20), but changed to mean +/- 3sd
      rename(approved_symbol = rowname) %>% 
      left_join(gene_summary, by = "approved_symbol") %>% 
      select(approved_symbol, approved_name, fav_gene) %>% 
      rename(gene = approved_symbol, name = approved_name, r2 = fav_gene)
    #this is to get neg correlators
      
    #pathway enrichment analyses
    flat_top_complete <- dep_top %>%
       pull("gene") %>% 
       c(fav_gene, .) %>% 
       enrichr_loop(., focused_lib)
     
     #bottom 
     flat_bottom_complete <- dep_bottom %>%
       pull("gene") %>% 
       enrichr_loop(., focused_lib)

    #plot setup
    target_achilles <- achilles_long %>% 
      filter(gene == fav_gene) %>% 
      left_join(expression_join, by = "X1") %>% 
      select(cell_line, lineage, dep_score)
    
    target_achilles_top <- target_achilles %>% 
      top_frac(dep_score, n = 0.01)
    
    target_achilles_bottom <- target_achilles %>% 
      top_frac(dep_score, n = -0.01) %>% 
      arrange(dep_score)
    
    #plot1
    dep_plot1 <- ggplot(target_achilles) +
      geom_histogram(aes(x = dep_score), binwidth = 0.25, color = "lightgray") +
      labs(x = "Dependency Score (binned)") + 
      theme_light()
    
    #plot2
    dep_plot2 <- ggplot(target_achilles) +
      geom_point(aes(x = fct_rev(fct_reorder(target_achilles$cell_line, target_achilles$dep_score, .desc = TRUE)), y = dep_score)) +
      labs(x = "Cell Lines", y = "Dependency Score") +
      geom_hline(yintercept = mean_virtual_achilles) +
      geom_hline(yintercept = 1, linetype="dashed") +
      geom_hline(yintercept = -1, linetype="dashed") +
      geom_hline(yintercept = 0) +
      geom_point(data = target_achilles_top, aes(x = cell_line, y = dep_score), color = "red") +
      geom_point(data = target_achilles_bottom, aes(x = cell_line, y = dep_score), color = "red") +
      theme_light() +
      theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) + # axis.title.x=element_blank()
      NULL
```
#### 1. Query YFG (your favorite gene)
As an example, we will query the protein P53. Typing in the given protein name "P53" produces an error, because the official gene symbol needs to be entered. Querying TP53 (official gene symbol) generates a short summary of the gene, its name and list of aliases, and an Entrez gene summary paragraph when available.  
  
#### Summary  
**Gene**: `r fav_gene_summary$approved_symbol`  
**Name**: `r fav_gene_summary$approved_name`  
**aka**: `r fav_gene_summary$aka`  
**Entrez ID**: `r as.integer(fav_gene_summary$ncbi_gene_id)`
  
`r fav_gene_summary$entrez_summary`  
  
#### 2. Dependencies
The first plot shows the distribution of dependency scores across `r length(achilles$X1)` cell lines ranked from lowest (strongest dependencies) to highest (no dependency or inverse). Each of the `r length(achilles$X1)` cell lines is represented by a single point on the plot. Generally, values below -1 indicate the gene of interest (`r fav_gene` in this example) is essential in that cell line; values between -1 and 0, mean that cells lose fitness, but the gene is not essential; values hovering around zero indicate that ablation of `r fav_gene` has little effect on cell growth; values above 1, indicate that knocking-out the gene leads to a fitness advantage. In the case of `r fav_gene`, several cells have a fitness advantage in its absence, consistent with its role as a tumor suppressor.  
  
The second plot is a histogram of dependency scores, showing the distribution of scores for `r fav_gene`. While the majority of cells have little change in cellular growth when `r fav_gene` is absent (the histogram is centered around zero), some cells require `r fav_gene` for growth (cells scoring below -1), whereas in other cells `r fav_gene` functions as a tumor suppressor (cells with a score above 1).  
  
  
```{r dep_plots, echo=FALSE}
dep_plot2 + dep_plot1
```
  
  
To identify the cells at the tails of the plots, a dependency table will show the ranked cells by dependency score, with cell lineage information appended. In some cases, specific cell types or lineages will show consistent patterns of dependency on a gene.  
  
  
#### Cells with strong `r fav_gene` genetic dependencies:
```{r target_achilles_top, echo=FALSE}
target_achilles_top %>% 
  mutate(dep_score = round(dep_score, 2)) %>% 
  rename("Cell Line" = "cell_line", "Lineage" = "lineage", "Dependency Score" = "dep_score") %>%
  pander::pander(justify = c("left", "left", "right"), split.cells = c("25%", "65%", "10%"))
```
  
  
  
#### Cells with low or inverse `r fav_gene` genetic dependencies
```{r target_achilles_bottom, echo=FALSE}
target_achilles_bottom %>% 
  mutate(dep_score = round(dep_score, 2)) %>% 
  rename("Cell Line" = "cell_line", "Lineage" = "lineage", "Dependency Score" = "dep_score") %>%
  pander::pander(justify = c("left", "left", "right"), split.cells = c("25%", "65%", "10%"))
```
  
  
  
Understanding the shape of the curve and distribution of the raw data underlying the patterns is important for interpreting the results.    
  
  
#### 3. Similar Patterns
Positive correlations of dependency scores are ranked for each gene. Recall that these genes show similar patterns of dependencies in the same cell lines. More simply, the cells that care about `r fav_gene` deletion also care about deletion of these genes, implying a functional relationship. In the Dependency Score Example heatmap schematic above, `r fav_gene` is gene X, and genes with similar patterns would be genes A, B, and C. The `r paste0(length(dep_top$gene))` genes that show a  similar genetic dependencies as `r fav_gene` and are above `r sd_threshold` standard deviations away from the resampled mean are displayed.  
  
  
```{r dep_top, echo=FALSE}
head(dep_top, 6) %>% 
  mutate(r2 = round(r2, 2)) %>% 
  rename("Gene" = "gene", "Gene Name" = "name", "R^2" = "r2")  %>%
  pander::pander(justify = c("left", "left", "right"), split.cells = c("25%", "65%", "10%"))
```
  
  
  
These `r paste0(length(dep_top$gene))` genes were queried for gene set enrichment, and the gene sets and pathways with the strongest statistical significance are shown. Simply stated, these are the pathways that best represent the list of genes that share similar genetic dependencies, and suggest that the query gene is part of these pathways.  
  
  
```{r flat_top_complete, echo=FALSE}
flat_top_complete %>% 
  select(enrichr, Term, Overlap) %>% 
  slice(1:10) %>% 
  rename("Gene Set" = "enrichr", "Gene List" = "Term")  %>%
  pander::pander(justify = c("left", "left", "right"), split.cells = c("20%", "70%", "10%"))
```
  
  
#### 4. Dissimilar
Like the analysis for genes that share similar patterns, this analysis can be used to find genes that share distinctly dissimilar patterns; that is, genes that have an inverse correlation of dependences. Simply stated, the cells that care about `r fav_gene` deletion *do not* care about deletion of these genes, implying an inverse or opposing relationship. In the Dependency Score Example heatmap schematic above, `r fav_gene` is gene X, and genes with dissimilar patterns would be genes D, E, and F. The `r paste0(length(dep_bottom$gene))` genes that show inverse genetic dependencies to `r fav_gene` and are below `r sd_threshold` standard deviations away from the resampled mean are:   
  
  
```{r dep_bottom, echo=FALSE}
head(dep_bottom, 6) %>% 
  mutate(r2 = round(r2, 2)) %>% 
  rename("Gene" = "gene", "Gene Name" = "name", "R^2" = "r2") %>%
  pander::pander(justify = c("left", "left", "right"), split.cells = c("25%", "65%", "10%"))
```
  
  
  
These `r paste0(length(dep_bottom$gene))` genes were also queried for gene set enrichment, and the gene sets and pathways with the strongest statistical significance are shown. Simply stated, these are the pathways that best represent the list of genes that have inverse genetic dependencies. 
  
  
```{r flat_bottom_complete, echo=FALSE}
flat_bottom_complete %>% 
  select(enrichr, Term, Overlap) %>% 
  slice(1:15) %>% 
  rename("Gene Set" = "enrichr", "Gene List" = "Term")  %>%
  pander::pander(justify = c("left", "left", "right"), split.cells = c("20%", "70%", "10%"))
```
  
  
  
How to interpret these genes and pathways is more variable than the positively correlated genes and pathways. In some cases, a negative regulator of a gene has a negative correlation with that gene, such as in this example with `r fav_gene` and its negative regulator `r dep_bottom$gene[1]`. In other cases, opposing *pathways* are shown, contrasting the `r fav_gene` enriched pathway term "`r flat_top_complete$Term[8]`" with the dissimilar enriched pathway term "`r flat_bottom_complete$Term[12]`", revealing two opposing biological pathways.    
  
  
#### 5. Graph
Identifying genes that share similar patterns of dependency to a queried unknown gene generates strong hypotheses about new functional annotations and maps to new pathways. However, the strength of the hypothesis cannot be fully inferred from single gene list. If a new gene is associated with the queried gene, then you might infer a functional relationship. However, if you inspect the top 10 genes with the queried gene, then inspect the top 10 genes of each of those, building a functional network graph of the top related genes might reveal a stronger association of the new gene with your queried gene *and* its top ranked genes.  
  
```{r static_graph, echo=FALSE, message=FALSE, warning=FALSE}
#enter static viz of gene networks

#setup graph 
threshold <- 10
deg <- 10
dep_network <- tibble()
  
 #find top and bottom correlations for fav_gene
  dep_top_slice <- dep_top %>% 
    slice(1:threshold)
  
  dep_bottom_slice <- dep_bottom %>% 
    slice(1:threshold) #limit for visualization?
  
  #this takes the genes from the top and bottom, and pulls them to feed them into a for loop
  related_genes <- dep_top_slice %>% 
    bind_rows(dep_bottom_slice) %>% 
    dplyr::pull("gene")
  
  #this loop will take each gene, and get their top and bottom correlations, and build a df containing the top n number of genes for each gene
  for (i in related_genes){
    message("Getting correlations related to ", fav_gene, ", including ", i)
    dep_top_related <- achilles_cor %>% 
      focus(i) %>% 
      arrange(desc(.[[2]])) %>% #use column index
      filter(.[[2]] > achilles_upper) %>% #formerly top_n(20), but changed to mean +/- 3sd
      mutate(x = i) %>% 
      rename(y = rowname, r2 = i) %>% 
      select(x, y, r2) %>% 
      slice(1:threshold) #limit for visualization?
    
    dep_bottom_related <- achilles_cor %>% 
      focus(i) %>% 
      arrange(.[[2]]) %>% #use column index
      filter(.[[2]] < achilles_lower) %>% #formerly top_n(20), but changed to mean +/- 3sd
      mutate(x = i) %>% 
      rename(y = rowname, r2 = i) %>% 
      select(x, y, r2) %>% 
      slice(1:threshold) #limit for visualization?
    
    #each temp object is bound together, and then bound to the final df for graphing
    dep_related <- dep_top_related %>% 
      bind_rows(dep_bottom_related)
    
    dep_network <- dep_network %>% 
      bind_rows(dep_related)
  }
  
    #make_graph_report
  graph_network <- tidygraph::as_tbl_graph(dep_network)
  nodes <-  as_tibble(graph_network) %>% 
    rowid_to_column("id") %>% 
    mutate(degree = igraph::degree(graph_network), 
           group = 1) %>% 
    arrange(desc(degree))
  
  links <- graph_network %>% 
    activate(edges) %>% # %E>%
    as_tibble()
  
  # determine the nodes that have at least the minimum degree
  nodes_filtered <- nodes %>%
    filter(degree >= deg) %>%  #input$degree
    as.data.frame
  
  # filter the edge list to contain only links to or from the nodes that have the minimum or more degree
  links_filtered <- links %>% 
    filter(to %in% nodes_filtered$id & from %in% nodes_filtered$id) %>% 
    as.data.frame
  
  links_filtered$from <- match(links_filtered$from, nodes_filtered$id)
  links_filtered$to <- match(links_filtered$to, nodes_filtered$id)
  
  graph_network_ggraph <- tidygraph::tbl_graph(nodes = nodes_filtered, edges = links_filtered)
  
  graph_network_ggraph %>%       
    ggraph(layout = "nicely") +      
    geom_edge_fan(aes(color = r2)) + #, color = 'steelblue'
    geom_node_point(aes(size = degree), color = 'black', alpha = 0.8) +   
    geom_node_label(aes(label = name), repel = TRUE) +
    scale_edge_color_viridis(option = "inferno") +
    theme_graph()
```
  
The data presented on datadrivenhypothesis.org is an interactive image that can be zoomed, dragged, and manipulated for data exploration; the static image above is a representative snapshot.  
  
## Where do I get more information? 
```{r include=FALSE}
#add publication data here first
```
Code is available on the Hirschey Lab github account, including links to download the raw data, and run the analyses in R from scratch. Furthermore, the Broad Institute has a lot of information on their [website](http://www.broadinstitute.org) and the website dedicated to the [Dependency Map project](http://www.depmap.org) about how the raw data were generated, and provide a list of references.  
  
#### Code Availability  
```{r include=FALSE}
#update these links!
```
[Generate Data](https://github.com/hirscheylab/ddh/blob/master/code/generate_depmap_data.R)  
[Statistical Analyses](https://github.com/hirscheylab/ddh/blob/master/code/generate_depmap_stats.R)  
[Table Generator](https://github.com/hirscheylab/ddh/blob/master/code/generate_depmap_tables.R)  
[Pathway Generator](https://github.com/hirscheylab/ddh/blob/master/code/generate_depmap_pathways.R)  
  
`r lubridate::stamp("Methods updated December 31, 1979")(now()) `
